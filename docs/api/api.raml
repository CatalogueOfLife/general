#%RAML 1.0
title: CoL Clearinghouse API
version: v1
baseUri: http://api.col.plus/
protocols:
  - HTTP
mediaType:
  - application/json
description:
    Public API of the Clearinghouse for taxonomy and nomenclature.
    The API currently gives access to staged source datasets for editorial review.
    The full Catalogue of Life and its versions is handled separately.
    In addition there is a secured, non public admin API, e.g. to request dataset to be (re)imported.
traits: !include inc/traits.raml
types: !include inc/types.raml
/admin: !include inc/admin.raml
/assembly: !include inc/assembly.raml
/broken:
  get:
    description: |
      List of broken editorial decisions.
    queryParameters:
      datasetKey:
        type: integer
        description: Filter by dataset
    responses:
      200:
        body:
          application/json:
            type: Decision[]
/colsource:
  get:
    description: |
      List of CoL sources.
    queryParameters:
      datasetKey:
        description: Filter by dataset
    responses:
      200:
        body:
          application/json:
            type: ColSource[]
/datapackage: !include inc/datapackage.raml
/dataset: !include inc/dataset.raml
/decision:
  get:
    description: |
      List of editorial decisions.
    queryParameters:
      datasetKey:
        type: integer
        description: Filter by dataset
      sectorKey:
        type: integer
        description: Filter by sector
    responses:
      200:
        body:
          application/json:
            type: Decision[]
            example: |
              [
                {
                  "created": "2019-10-10T18:12:03.457967",
                  "createdBy": 100,
                  "modified": "2019-10-10T18:12:03.457967",
                  "modifiedBy": 100,
                  "key": 6,
                  "datasetKey": 3,
                  "subject": {
                    "id": "12749-syn-1",
                    "name": "Acrophorus hookeri",
                    "authorship": "Moore",
                    "rank": "species"
                  },
                  "subjectDatasetKey": 1140,
                  "mode": "block",
                  "status": "ambiguous synonym"
                }
              ]
  post:
    body:
      application/json:
        example: |
          {
            "subjectDatasetKey": "1140",
            "subject": {
              "id": "12749-syn-1",
              "name": "Acrophorus hookeri",
              "authorship": "Moore",
              "rank": "species"
            },
            "mode": "block",
            "status": "ambiguous synonym"
          }
    responses:
      200:
        body:
          type: integer
          description: the decision key
          example: '6'
/sector:
  get:
    description: |
      List of taxonomic sectors in the CoL.
      queryParameters:
        sourceKey:
          description: Filter by CoL source.
    responses:
      200:
        body:
          application/json:
            type: Sector[]
/importer:
  get:
    description: Retrieve import metrics sorted chronologically descending.
    is: [paged,filteredByDataset]
    queryParameters:
      datasetKey:
        type: integer
        description: Filter by dataset
      state:
        type: ImportState
        description: filters listed import metrics by their state, e.g. the last failed import
    responses:
      200:
        body: DatasetImportResultSet
  /queue:
    get:
      description: Retrieve import metrics sorted chronologically descending.
      is: [paged,filteredByDataset]
      queryParameters:
        state:
          type: ImportState
          description: filters listed import metrics by their state, e.g. the last failed import
      responses:
        200:
          body: ImportRequest[]
/name/search:
  get:
    displayName: Name search
    description: Executes a name search.
    is: [paged]
    queryParameters:
      q:
        type: string
        description: main query string
        required: false
      datasetKey:
        type: integer
        description: dataset key
        required: false
      id:
        type: string
        description: the name identifier
        required: false
      rank:
        type: RankType
        description: filter by rank
        required: false
      nomstatus:
        type: NomenclaturalStatusType
        description: filter by nomenclatural status
        required: false
      status:
        type: TaxonomicStatusType
        description: filter by taxonomic status
        required: false
      issue:
        type: string
        description: filter by issue found
        required: false
      type:
        type: NameType
        description: filter by name type
        required: false
      publishedIn:
        type: string
        description: publishedIn reference id to filter names by
        required: false
      hasField:
        type: string
        enum: []
        description: filter that only includes name where the requested name property is not null
        required: false        
      facet:
        type: string
        enum: [ "dataset_key","rank","nom_status","status","issue","type","field"]
        description: request a facet to be returned. The facet limit defaults to 50
        required: false
      sortBy:
        type: string
        enum: ["relevance", "name", "key"]
        description: sort order
        required: false
    responses:
      200:
        body:
          application/json:
            type: NameSearchResultSet
/name/suggest:
  get:
    displayName: Name suggest
    description: Name suggestion service (a.k.a. auto-complete)
    queryParameters:
      q:
        type: string
        description: main query string
        required: true
      datasetKey:
        type: integer
        description: dataset key
        required: true
      vernaculars:
        type: boolean
        description: Whether or not to include vernacular names in the suggestions (default false)
        required: false
      limit:
        type: integer
        description: The desired number of suggestions (default 10)
        required: false
    responses:
      200:
        body:
          application/json:
            type: string
/name/matching:
  get:
    description: |
      Match name against the name index.
      Eventually should be exposed in public API.
    queryParameters:
      q:
        type: string
        description: scientific name to match
      rank:
        type: RankType
        description: rank to restrict matches to
        required: false
      code:
        type: NomCodeType
        description: nomenclatural code to restrict matches to
        required: false
      trusted:
        type: boolean
        description: if true unmatched name will be inserted into the names index
        default: false
      verbose:
        type: boolean
        description: if verbose list alternatively considered name matches
        default: false
    responses:
      200:
        body:
          application/json:
            type: NameMatch 
/parser:
  /name:
    get:
      displayName: List parsed names
      description: List parsed names.
      queryParameters:
        name:
          description: The names to parse (may occur multiple times)
      responses:
        200:
          body:
            application/json:
              type: Name[]
    post:
      displayName: List parsed names
      description: |
        List parsed names. The names to be parsed can be specified as a JSON array in the request body; a file upload
        with one name per line, or as plain/text content in the request body.
      body:
        application/json:
          description: A JSON array of names to be parsed
        multipart/form-data:
          description: A file upload; one name per line
        text/plain:
          description: A plain/text content body; one name per line
      responses:
        200:
          body:
            application/json:
              type: Name[]
/vocab:
  get:
    description: |
      List of all available vocabularies by their unique lowercase form.
      Any of the names can be used as valid subresources to list the actual enumeration values.
    responses:
      200:
        body:
          application/json:
            type: string[]
            example: |
              ["continent","country","areastandard","cslreftype","nametype","origin","language","frequency","rank","nomacttype","coverage","nomstatus","dataformat","importstate","issue","gazetteer","cslvariable","typestatus","lifezone","distributionstatus","taxonomicstatus","kingdom","datasettype","license","nomcode","namepart"]
  /{name}:
    get:
      description: |
        List of all enumeration values for the requested vocabulary.
      responses:
        200:
          body:
            application/json:
              type: string[]
              example: |
                ["domain","superkingdom","kingdom","subkingdom","infrakingdom","superphylum","phylum","subphylum","infraphylum","superclass","class","subclass","infraclass","parvclass","superlegion","legion","sublegion","infralegion","supercohort","cohort","subcohort","infracohort","magnorder","superorder","grandorder","order","suborder","infraorder","parvorder","superfamily","family","subfamily","infrafamily","supertribe","tribe","subtribe","infratribe","suprageneric name","genus","subgenus","infragenus","supersection","section","subsection","superseries","series","subseries","infrageneric name","species aggregate","species","infraspecific name","grex","subspecies","cultivar group","convariety","infrasubspecific name","proles","natio","aberration","morph","variety","subvariety","form","subform","pathovar","biovar","chemovar","morphovar","phagovar","serovar","chemoform","forma specialis","cultivar","strain","other","unranked"]
