#%RAML 1.0
title: CoL Clearinghouse API
version: v1
baseUri: http://api.catalogue.life/
protocols:
  - HTTP
mediaType:
  - application/json
description:
    Public API of the Clearinghouse for taxonomy and nomenclature.
    The API currently gives access to staged source datasets for editorial review.
    The full Catalogue of Life and its versions is handled separately.
    In addition there is a secured, non public admin API, e.g. to request dataset to be (re)imported.
securitySchemes:
  basic:
    description: |
      This API supports Basic Authentication over SSL.
    type: Basic Authentication
  jwt:
    description: |
      This API supports JSON Web Tokens which are issued by the API's user login method.
      JWT is a special type of the Bearer token authentication.
      See https://jwt.io/ for details.
    type: x-custom
    describedBy:
      headers:
        Authorization:
          type: bearerJWT
          description: |
            Used to send the Bearer JWT token
      responses:
        401:
          description: |
            Bad or expired token. This can happen if the user revoked or expired an access token. To fix, re-authenticate the user.
securedBy: [basic, jwt]
traits: !include inc/traits.raml
types: !include inc/types.raml
/admin: !include inc/admin.raml
/assembly: !include inc/assembly.raml
/datapackage: !include inc/datapackage.raml
/dataset: !include inc/dataset.raml
/decision:
  get:
    is: paged
    description: |
      List of editorial decisions with optional filters.
    queryParameters:
      datasetKey:
        type: integer
        description: The catalogue dataset the decision applies to
      subjectDatasetKey:
        type: integer
        description: The source dataset the subject belongs to
      userKey:
        type: integer
        description: The user that last modified the decision
      rank:
        type: RankType
        description: The rank of the subject
      mode:
        type: DecisionMode
        description: The decision mode, e.g. BLOCK
      broken:
        type: boolean
        description: if true only show decisions which cannot be linked to a source name usage
    responses:
      200:
        body:
          application/json:
            type: DecisionResultSet
            example: |
                {
                  "offset": 0,
                  "limit": 1,
                  "total": 224,
                  "result": [
                    {
                      "created": "2019-10-10T18:12:03.457967",
                      "createdBy": 100,
                      "modified": "2019-10-10T18:12:03.457967",
                      "modifiedBy": 100,
                      "key": 6,
                      "datasetKey": 3,
                      "subject": {
                        "id": "12749-syn-1",
                        "name": "Acrophorus hookeri",
                        "authorship": "Moore",
                        "rank": "species"
                      },
                      "subjectDatasetKey": 1140,
                      "mode": "block",
                      "status": "ambiguous synonym"
                    }
                  ],
                  "last": false,
                  "empty": false
                }            
  post:
    body:
      application/json:
        example: |
          {
            "datasetKey": "3",
            "subjectDatasetKey": "1140",
            "subject": {
              "id": "12749-syn-1",
              "name": "Acrophorus hookeri",
              "authorship": "Moore",
              "rank": "species"
            },
            "mode": "block",
            "status": "ambiguous synonym"
          }
    responses:
      200:
        body:
          type: integer
          description: the decision key
          example: '6'
/estimate:
  displayName: Species estimates
  description: Species estimates are linked to a target taxon of a managed catalogue.
  get:
    is: paged
    description: |
      Page through species estimates with optional filters.
    queryParameters:
      datasetKey:
        type: integer
        description: The catalogue dataset the estimate applies to
      userKey:
        type: integer
        description: The user that last modified the estimate
      rank:
        type: RankType
        description: The rank of the subject
      min:
        description: the minimum number of estimated species
        type: integer
        required: false
      max:
        description: the maximum number of estimated species
        type: integer
        required: false
      broken:
        type: boolean
        description: if true only show estimates which cannot be linked to their target name usage
    responses:
      200:
        body:
          application/json:
            type: SpeciesEstimateResultSet
            example: |
              {
                "offset": 0,
                "limit": 1,
                "total": 1266,
                "result": [
                  {
                    "created": "2015-10-08T22:51:08",
                    "createdBy": 0,
                    "modified": "2018-04-09T17:54:39",
                    "modifiedBy": 0,
                    "key": 68,
                    "datasetKey": 3,
                    "target": {
                      "id": "061950e4-9782-4d1a-9c87-dcf375788e6b",
                      "name": "Animalia",
                      "rank": "kingdom",
                      "code": "zoological"
                    },
                    "estimate": 1525728,
                    "type": "described species living",
                    "referenceId": "27"
                  }
                ],
                "last": false,
                "empty": false
              }
  /{key}:
    get:
      displayName: Get one species estimate by its key
      description: Retrieves the estimate with the specified key.
      responses:
        200:
          body:
            application/json:
              type: SpeciesEstimate
              example: |
                {
                  "created": "2015-10-08T22:51:08",
                  "createdBy": 0,
                  "modified": "2018-04-09T17:54:39",
                  "modifiedBy": 0,
                  "key": 68,
                  "datasetKey": 3,
                  "target": {
                    "id": "061950e4-9782-4d1a-9c87-dcf375788e6b",
                    "name": "Animalia",
                    "rank": "kingdom",
                    "code": "zoological"
                  },
                  "estimate": 1525728,
                  "type": "described species living",
                  "referenceId": "27"
                }
    delete:
      displayName: Delete estimate
      description: Deletes the estimate with the specified estimate key.
      responses:
        204:
          description: Estimate deleted.
        404:
          description: Specified estimate key does not exist.
    put:
      displayName: Update estimate
      description: Updates the estimate specified through the JSON request body.
      body:
        application/json:
          type: SpeciesEstimate
      responses:
        204:
          description: Estimate updated.
        404:
          description: Specified estimate key does not exist.
    uriParameters:
      key:
        type: integer
        description: species estimate key
/sector:
  displayName: Taxonomic sectors
  description: > 
      Sectors are taxonomic groups that are represented by a subtree with a single root taxon.
      They link a subject (the root taxon in a source dataset) 
      to a target (the attachment point) in a managed catalogue.
  get:
    is: paged
    description: |
      Page through sectors with optional filters.
    queryParameters:
      id:
        type: string
        description: The subjects taxon id
      datasetKey:
        type: integer
        description: The catalogue dataset the sector is attached to
      subjectDatasetKey:
        type: integer
        description: The source dataset the subject belongs to
      userKey:
        type: integer
        description: The user that last modified the sector
      rank:
        type: RankType
        description: The rank of the subject
      mode:
        type: SectorMode
        description: The sector mode, e.g. ATTACH
      broken:
        type: boolean
        description: if true only show decisions which cannot be linked to a source name usage
    responses:
      200:
        body:
          application/json:
            type: SectorResultSet            
  post:
    body:
      application/json:
        type: Sector
    responses:
      201:
        body:
          application/json:
            description: the new sectors key
            type: integer
            example: 2051
/importer:
  get:
    description: Retrieve import metrics sorted chronologically descending.
    is: [paged,filteredByDataset]
    queryParameters:
      datasetKey:
        type: integer
        description: Filter by dataset
        required: false
      state:
        type: ImportState
        description: filters listed import metrics by their state, e.g. the last failed import
        required: false
      running:
        type: boolean
        description: if only a list of running imports should be returned
        required: false
    responses:
      200:
        body: DatasetImportResultSet
  post:
    displayName: Start an import
    description: Starts an import process
    body:
      application/json:
        required: true
        type: ImportRequest
        example: |
          {
            "datasetKey": 1163,
            "priority": true,
            "force": true
          }
    responses:
      201:
        body:
          application/json:
            example: |
              {
                "datasetKey": 1163,
                "force": true,
                "priority": true,
                "createdBy": 100,
                "created": "2019-10-10T20:23:09.617",
                "started": "2019-10-10T20:23:09.633"
              }
  /{key}:
    get:
      displayName: Gets the import status and import metrics
      description: Returns import status and metrics for dataset {key}
      responses:
        200:
          body:
            application/json:
              example: |
                # inserting import
                {
                  "datasetKey": 1140,
                  "attempt": 4,
                  "state": "inserting",
                  "started": "2019-10-10T20:40:08.724",
                  "downloadUri": "https://raw.githubusercontent.com/Sp2000/colplus-repo/master/ACEF/140.tar.gz",
                  "download": "2019-10-10T20:40:09",
                  "md5": "FD4D41F0B279ADAB297873A3578EBC6C",
                  "usagesCount": 0
                }

                # completed import
                {
                  "datasetKey": 2050,
                  "attempt": 2,
                  "state": "finished",
                  "started": "2019-10-09T21:58:38.858",
                  "finished": "2019-10-09T21:58:41.856",
                  "nameCount": 106,
                  "taxonCount": 84,
                  "synonymCount": 22,
                  "referenceCount": 0,
                  "distributionCount": 0,
                  "vernacularCount": 0,
                  "namesByTypeCount": {
                    "scientific": 106
                  },
                  "namesByOriginCount": {
                    "denormed classification": 55,
                    "source": 51
                  },
                  "namesByRankCount": {
                    "species": 33,
                    "genus": 17,
                    "order": 13,
                    "family": 13,
                    "subspecies": 10,
                    "variety": 8,
                    "class": 4,
                    "phylum": 3,
                    "kingdom": 2,
                    "superfamily": 2,
                    "subgenus": 1
                  },
                  "usagesByStatusCount": {
                    "accepted": 84,
                    "synonym": 22
                  },
                  "taxaByRankCount": {
                    "species": 22,
                    "genus": 17,
                    "order": 13,
                    "family": 13,
                    "subspecies": 5,
                    "class": 4,
                    "phylum": 3,
                    "kingdom": 2,
                    "superfamily": 2,
                    "variety": 2,
                    "subgenus": 1
                  },
                  "issuesCount": {
                    "duplicate name": 28,
                    "name match variant": 4,
                    "doubtful name": 1,
                    "null epithet": 1,
                    "name match inserted": 1
                  },
                  "download": "2019-10-09T21:58:38",
                  "md5": "CDEFD4617558457733F782D1ACACD284",
                  "verbatimCount": 102,
                  "verbatimByTypeCount": {
                    "col:Name": 51,
                    "col:Synonym": 22,
                    "col:Taxon": 29
                  },
                  "verbatimByTermCount": {
                    "col:Name": {
                      "col:ID": 51,
                      "col:code": 51,
                      "col:link": 34,
                      "col:rank": 51,
                      "col:genus": 51,
                      "col:remarks": 34,
                      "col:authorship": 50,
                      "col:scientificName": 51,
                      "col:specificEpithet": 51,
                      "col:infraspecificEpithet": 17,
                      "http://unknown.org/col/databaseID": 51
                    },
                    "col:Taxon": {
                      "col:ID": 29,
                      "col:link": 14,
                      "col:class": 29,
                      "col:genus": 29,
                      "col:order": 29,
                      "col:family": 29,
                      "col:nameID": 29,
                      "col:phylum": 29,
                      "col:kingdom": 29,
                      "col:remarks": 14,
                      "col:lifezone": 5,
                      "col:parentID": 4,
                      "col:subgenus": 2,
                      "col:accordingTo": 29,
                      "col:provisional": 29,
                      "col:superfamily": 5,
                      "col:accordingToDate": 29,
                      "http://unknown.org/col/fossil": 29,
                      "http://unknown.org/col/recent": 29,
                      "http://unknown.org/col/databaseID": 29
                    },
                    "col:Synonym": {
                      "col:nameID": 22,
                      "col:status": 22,
                      "col:remarks": 22,
                      "col:taxonID": 22,
                      "http://unknown.org/col/databaseID": 22
                    }
                  },
                  "usagesCount": 106
                }
        404:
          body:
            application/json:
              example: |
                {
                  "code": 404,
                  "message": "HTTP 404 Not Found"
                }
    post:
      displayName: Import a dataset
      description: |
        Triggers an import for dataset {key}
        Optionally a compressed archive of data (zip or gzip) can be included
      body:
        application/octet-stream:
          required: false
        application/zip:
          required: false
        application/gzip:
          required: false
      responses:
        201:
          body:
            application/json:
              example: |
                {
                  "datasetKey": 2050,
                  "force": true,
                  "priority": true,
                  "createdBy": 100,
                  "created": "2019-10-10T20:49:01.592",
                  "started": "2019-10-10T20:49:01.596"
                }
    delete:
      displayName: Cancel an import
      description: Deletes an import from the importer queue
      responses:
        204:
/nameusage:
  /search:
    get:
      displayName: Name search
      description: Executes a name search.
      is: [paged]
      queryParameters:
        q:
          type: string
          description: main query string
          required: false
        datasetKey:
          type: integer
          description: dataset key
          required: false
        id:
          type: string
          description: the name identifier
          required: false
        rank:
          type: RankType
          description: filter by rank
          required: false
        nomstatus:
          type: NomenclaturalStatusType
          description: filter by nomenclatural status
          required: false
        status:
          type: TaxonomicStatusType
          description: filter by taxonomic status
          required: false
        issue:
          type: string
          description: filter by issue found
          required: false
        type:
          type: NameType
          description: filter by name type
          required: false
        publishedIn:
          type: string
          description: publishedIn reference id to filter names by
          required: false
        hasField:
          type: string
          enum: []
          description: filter that only includes name where the requested name property is not null
          required: false        
        facet:
          type: string
          enum: [ "dataset_key","rank","nom_status","status","issue","type","field"]
          description: request a facet to be returned. The facet limit defaults to 50
          required: false
        sortBy:
          type: string
          enum: ["relevance", "name", "key"]
          description: sort order
          required: false
      responses:
        200:
          body:
            application/json:
              type: NameSearchResultSet
  /suggest:
    get:
      displayName: Name suggest
      description: Name suggestion service (a.k.a. auto-complete)
      queryParameters:
        q:
          type: string
          description: main query string
          required: true
        datasetKey:
          type: integer
          description: dataset key
          required: true
        vernaculars:
          type: boolean
          description: Whether or not to include vernacular names in the suggestions (default false)
          required: false
        limit:
          type: integer
          description: The desired number of suggestions (default 10)
          required: false
      responses:
        200:
          body:
            application/json:
              type: string
/name/matching:
  get:
    description: |
      Match name against the name index.
      Eventually should be exposed in public API.
    queryParameters:
      q:
        type: string
        description: scientific name to match
      rank:
        type: RankType
        description: rank to restrict matches to
        required: false
      code:
        type: NomCodeType
        description: nomenclatural code to restrict matches to
        required: false
      trusted:
        type: boolean
        description: if true unmatched name will be inserted into the names index
        default: false
      verbose:
        type: boolean
        description: if verbose list alternatively considered name matches
        default: false
    responses:
      200:
        body:
          application/json:
            type: NameMatch
            example: |
              {
                "name": {
                  "created": "2019-10-13T10:58:24.938404",
                  "createdBy": 11,
                  "modified": "2019-10-13T10:58:24.938404",
                  "modifiedBy": 11,
                  "datasetKey": 2,
                  "id": "5SYL",
                  "sectorKey": 4433,
                  "homotypicNameId": "5SYL",
                  "scientificName": "Atta",
                  "rank": "genus",
                  "uninomial": "Atta",
                  "candidatus": false,
                  "nomStatus": "doubtful",
                  "origin": "name matching",
                  "type": "scientific",
                  "parsed": true,
                  "formattedName": "<i>Atta</i>"
                },
                "type": "exact"
              }
/parser:
  /name:
    get:
      displayName: List parsed names
      description: List parsed names.
      queryParameters:
        name:
          description: The names to parse (may occur multiple times)
      responses:
        200:
          body:
            application/json:
              type: Name[]
    post:
      displayName: List parsed names
      description: |
        List parsed names. The names to be parsed can be specified as a JSON array in the request body; a file upload
        with one name per line, or as plain/text content in the request body.
      body:
        application/json:
          description: A JSON array of names to be parsed
        multipart/form-data:
          description: A file upload; one name per line
        text/plain:
          description: A plain/text content body; one name per line
      responses:
        200:
          body:
            application/json:
              type: Name[]
/user:
  /{userKey}:
    get:
      displayName: Gets user information
      description: Returns username, first name, last name, country
      responses:
        200:
          body:
            application/json:
              example: |
                {
                  "key": 1,
                  "username": "L",
                  "firstname": "Carl",
                  "lastname": "Linnaeus",
                  "country": "SE"
                }
        404:
          body:
            application/json:
              example: |
                {
                  "code": 404,
                  "message": "HTTP 404 Not Found"
                }
  /me:
    get:
      displayName: Gets logged in user's information
      description: Returns username, first name, last name, country
      responses:
        200:
          body:
            application/json:
              example: |
                {
                  "key": 1,
                  "username": "L",
                  "firstname": "Carl",
                  "lastname": "Linnaeus",
                  "email": "l@catalogue.life",
                  "country": "SE",
                  "roles": [
                    "user",
                    "editor",
                    "admin"
                  ],
                  "lastLogin": "1777-10-10T18:59:21.734"
                }
  /login:
    get:
      displayName: user login
      description: Login as a user to gain a new JWT token
      securedBy: [basic]
      responses:
        200:
          body:
            text/plain:
              type: jwt
              example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzY290Y2guaW8iLCJleHAiOjEzMDA4MTkzODAsIm5hbWUiOiJDaHJpcyBTZXZpbGxlamEiLCJhZG1pbiI6dHJ1ZX0.03f329983b86f7d9a9f5fef85305880101d5e302afafa20154d094b229f75773
  /settings:
    put:
      displayName: Sets user settings
      description: Updates the user settings
      securedBy: [basic, jwt]
      body:
        application/json:
          example: |
              {
                "mysetting1": "myvalue1",
                "favoriteColor": "red"
              }
/version:
  get:
    displayName: Returns the CoL+ API version
    description: The CoL+ API version is the GitHub commit hash and time (e.g., https://github.com/Sp2000/colplus-backend/tree/70d8d5b).
    responses:
      200:
        body:
          text/plain:
            example:  |
              "70d8d5b  2019-10-09T14:26:15+0000"
            type: string
/vocab:
  get:
    description: |
      List of all available vocabularies by their unique lowercase form.
      Any of the names can be used as valid subresources to list the actual enumeration values.
    responses:
      200:
        body:
          application/json:
            type: string[]
            example: |
              ["continent","country","areastandard","cslreftype","nametype","origin","language","frequency","rank","nomacttype","coverage","nomstatus","dataformat","importstate","issue","gazetteer","cslvariable","typestatus","lifezone","distributionstatus","taxonomicstatus","kingdom","datasettype","license","nomcode","namepart"]
  /{name}:
    get:
      description: |
        List of all enumeration values for the requested vocabulary.
      responses:
        200:
          body:
            application/json:
              type: string[]
              example: |
                ["domain","superkingdom","kingdom","subkingdom","infrakingdom","superphylum","phylum","subphylum","infraphylum","superclass","class","subclass","infraclass","parvclass","superlegion","legion","sublegion","infralegion","supercohort","cohort","subcohort","infracohort","magnorder","superorder","grandorder","order","suborder","infraorder","parvorder","superfamily","family","subfamily","infrafamily","supertribe","tribe","subtribe","infratribe","suprageneric name","genus","subgenus","infragenus","supersection","section","subsection","superseries","series","subseries","infrageneric name","species aggregate","species","infraspecific name","grex","subspecies","cultivar group","convariety","infrasubspecific name","proles","natio","aberration","morph","variety","subvariety","form","subform","pathovar","biovar","chemovar","morphovar","phagovar","serovar","chemoform","forma specialis","cultivar","strain","other","unranked"]
